{"componentChunkName":"component---src-templates-blog-post-js","path":"/2020/05/17/","result":{"data":{"site":{"siteMetadata":{"title":"SetValue.NET","author":"Raúl Fernández de Córdoba","siteUrl":"http://setvalue.net"}},"markdownRemark":{"id":"39e74fe5-2edd-5f39-be7c-0f5940772d3a","excerpt":"Generic badge Siguiendo con el anterior post en el que construíamos un sitio estático con GatsbyJS, nos enfrentamos a desplegar el resultado de esta web en un…","html":"<p><a href=\"https://github.com/rfcm83/DemoGatsbyJS/\"><img src=\"https://img.shields.io/badge/rfcm83-DemoGatsbyJS-%3CCOLOR%3E.svg\" alt=\"Generic badge\"></a></p>\n<p>Siguiendo con el anterior <a href=\"../16\">post</a> en el que construíamos un sitio estático con GatsbyJS, nos enfrentamos a desplegar el resultado de esta web en un nuevo sitio de GitHub Pages.</p>\n<p>Para desplegar la aplicación, utilizaremos <a href=\"https://dev.azure.com\" target=\"_blank\">Azure DevOps</a>, creando dos pipelines, uno para la integración continua (CI <em>Continuous Integration</em>) y otro para la entrega continua (CD <em>Continuous Delivery</em>).</p>\n<h2>Configurando el repositorio</h2>\n<p>El primer paso que debemos realizar es preparar el repositorio para activar y configurar GitHub Pages.</p>\n<p>Creamos un nuevo branch llamado <code>gh-pages</code> en el repositorio donde tenemos el sitio estático hecho con GatsbyJS.</p>\n<p><img src=\"../../../assets/blog/BranchCreateGH-Pages.png\" alt=\"New branch\"></p>\n<p>Configuramos GitHub Pages en este repositorio desde la pestaña de settings.</p>\n<p><img src=\"../../../assets/blog/GitHubPages-Settings.png\" alt=\"GitHub Pages Settings\"></p>\n<blockquote>\n<p><strong>Nota</strong>: Si tienes un Custom Domain ya agregado, GitHub Pages te sirve todos los sitios web desde el dominio que has configurado</p>\n</blockquote>\n<p>Por último, necesitaremos configurar un <a href=\"https://github.com/settings/tokens\" target=\"_blank\">PAT (Personal access token)</a> con permisos sobre repo.</p>\n<p><img src=\"../../../assets/blog/NewPAT.png\" alt=\"Create a new PAT\"></p>\n<p>Almacenamos el token en un lugar seguro para utilizarlo más adelante.</p>\n<p><img src=\"../../../assets/blog/PAT.png\" alt=\"New PAT\"></p>\n<h2>Azure DevOps</h2>\n<p>En Azure DevOps debemos crear dos pipelines, el primero hará la build de la solución y generará un artefacto, el segundo utilizará este artefacto y lo publicará en la rama <code>gh-pages</code> del repositorio en el que estamos trabajando.</p>\n<h3>Pipeline</h3>\n<p>Dentro del Team Project, en el menú seleccionamos el ítem <strong>Pipelines</strong>.</p>\n<p><img src=\"../../../assets/blog/Pipeline-Step0.png\" alt=\"Pipeline\"></p>\n<p>Creamos un nuevo pipeline y elegimos como origen GitHub.</p>\n<p><img src=\"../../../assets/blog/Pipeline-Step1.png\" alt=\"Connect Pipeline\"></p>\n<p>Seleccionamos el repositorio que queremos publicar como sitio estático.</p>\n<p><img src=\"../../../assets/blog/Pipeline-Step2.png\" alt=\"Select Pipeline\"></p>\n<p>Al escoger el repositorio, deberemos configurar en GitHub el acceso que va a tener Azure Pipelines sobre nuestro repositorio. Tenemos dos opciones, dejar que tenga acceso a todos los repositorios, o dejar que sólo tenga acceso a los repositorios que seleccionemos.</p>\n<p><img src=\"../../../assets/blog/Pipeline-Step2-Setup.png\" alt=\"Setup Azure Pipelines\"></p>\n<p>Tras aprobar el acceso al repositorio, volvemos al pipeline, y lo configuramos para que utilice Node.js.</p>\n<p><img src=\"../../../assets/blog/Pipeline-Step3.png\" alt=\"Configure Pipeline\"></p>\n<p>En el último paso nos encontramos con un fichero YAML, con el nombre preestablecido de azure-pipelines.yml y que se almacenará en el repositorio de GitHub.</p>\n<p>Este fichero, viene por defecto con un trigger que se desencadenará cuando se consoliden cambios en <code>master</code>, además realiza la instalación de Node.js, ejecuta la instalación de los paquetes npm y la compilación de la solución.</p>\n<pre><code class=\"language-yaml\"># Node.js\n# Build a general Node.js project with npm.\n# Add steps that analyze code, save build artifacts, deploy, and more:\n# https://docs.microsoft.com/azure/devops/pipelines/languages/javascript\n\ntrigger:\n- master\n\npool:\n  vmImage: 'ubuntu-latest'\n\nsteps:\n- task: NodeTool@0\n  inputs:\n    versionSpec: '10.x'\n  displayName: 'Install Node.js'\n\n- script: |\n    npm install\n    npm run build\n  displayName: 'npm install and build'\n</code></pre>\n<p>Actualizamos el código YAML que viene por defecto, modificando los pasos de la operativa para que instale el <code>Gatsby-CLI</code>, y con <code>yarn</code> instale las dependencias y haga la build de la solución.</p>\n<pre><code class=\"language-yaml\"># Build a GatsbyJS solution with npm and yarn.\n\ntrigger:\n- master\n\npool:\n  vmImage: 'ubuntu-latest'\n\nsteps:\n- task: NodeTool@0\n  inputs:\n    versionSpec: '10.x'\n  displayName: 'Install Node.js'\n\n- script: |\n    npm install -g gatsby-cli\n  displayName: 'Install Gatsby-CLI'\n\n- script: |\n    yarn install\n  displayName: 'Install dependencies'\n\n- script: |\n    yarn build\n  displayName: 'Build'\n</code></pre>\n<p>En el lateral derecho, tenemos la posibilidad de utilizar el asistente, el cual nos permitirá cargar nuevos pasos dentro del YAML para completar el pipeline.</p>\n<p><img src=\"../../../assets/blog/Pipeline-Step4-Assistant.png\" alt=\"Pipeline Assistant\"></p>\n<p>Agregamos dos pasos nuevos, el primero realizará la copia de los ficheros generados en la build. El segundo paso la publicación del resultado como artefacto.</p>\n<p>Para la copia de los ficheros, agregamos la tarea de copia e indicamos que debe copiar los ficheros que se generan en la carpeta <em>public</em> al <em>Build Artifact Staging Directory</em>.</p>\n<pre><code class=\"language-yaml\">- task: CopyFiles@2\n  inputs:\n    sourceFolder: \"public\"\n    contents: \"**\"\n    targetFolder: \"$(Build.ArtifactStagingDirectory)\"\n    cleanTargetFolder: true\n  displayName: \"Copy built site\"\n  condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))\n</code></pre>\n<p>Tras la copia de ficheros, publicamos el resultado en el <em>Staging Artifact Directory</em>.</p>\n<pre><code class=\"language-yaml\">- task: PublishBuildArtifacts@1\n  inputs:\n    PathtoPublish: \"$(Build.ArtifactStagingDirectory)\"\n    ArtifactName: \"drop\"\n    publishLocation: \"Container\"\n  condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))\n  displayName: \"Publish Build Artifacts\"\n</code></pre>\n<p>Al finalizar las modificaciones, salvamos, establecemos el mensaje de <code>commit</code> y automáticamente se lanzará un pipeline que generará los ficheros estáticos necesarios para un sitio web de GitHub Pages. </p>\n<p><img src=\"../../../assets/blog/Pipeline-SaveAndRun.png\" alt=\"Pipeline Saven and run\"></p>\n<p>Una vez lanzado el pipeline, vemos el estado de la ejecución, y tenemos la posibilidad de ver los cambios o cancelar el propio pipeline.</p>\n<p><img src=\"../../../assets/blog/Pipeline-Run.png\" alt=\"Pipeline Run\"></p>\n<p>Si pulsamos en el Job, podemos acceder al estado de la ejecución del pipeline y ver cómo va avanzando.</p>\n<p><img src=\"../../../assets/blog/Pipeline-Run-Log.png\" alt=\"Pipeline Log\"></p>\n<p>Tras ejecutarse el pipeline, si no ha habido ningún error tendremos un tick verde en el resultado del Job, e internamente, en los logs, todas las operaciones estarán Ok y habrá un artefacto generado.</p>\n<p><img src=\"../../../assets/blog/Pipeline-Run-Completed.png\" alt=\"Pipeline Log\"></p>\n<h3>Release</h3>\n<p>Accedemos al ítem <strong>Release</strong>, dentro del menú Pipelines.</p>\n<p><img src=\"../../../assets/blog/Release-Step0.png\" alt=\"Release Menu\"></p>\n<p>Creamos una nueva Release Pipeline.</p>\n<p><img src=\"../../../assets/blog/Release-Step1.png\" alt=\"New Release Pipeline\"></p>\n<p>En pantalla se nos mostrará un workflow para configurar nuestro <code>Release Pipeline</code>, por defecto Azure DevOps nos ofrece plantillas predefinidas con diversa funcionalidad para facilitar esta tarea. En nuestro caso, seleccionamos una plantilla vacía.</p>\n<p><img src=\"../../../assets/blog/Release-Step2.png\" alt=\"Select Template\"></p>\n<p>Establecemos un nombre al Stage, y vamos al bloque <code>Artifacts</code>, dónde configuraremos el artefacto resultante de la pipeline que hemos creado en el punto anterior.</p>\n<p><img src=\"../../../assets/blog/Release-Step3.png\" alt=\"Select Artifact\"></p>\n<p>Después de agregarlo, configuramos el trigger que desencadenará la <code>Release Pipeline</code>, pulsando en el símbolo del <em>rayo</em> del artefacto e indicamos la entrega continua con cada build que se produzca.</p>\n<p><img src=\"../../../assets/blog/Release-Step4.png\" alt=\"Continuous deployment trigger\"></p>\n<p>En el bloque de <code>Stages</code>, accedemos al Stage que tenemos y pulsamos sobre el resumen de <em>1 job, 0 task</em>.</p>\n<p><img src=\"../../../assets/blog/Release-Step5.png\" alt=\"Tasks Stage\"></p>\n<p>En el job del agente agregamos una nueva tarea del tipo <em>Publish to GitHub Pages</em> y configuramos la tarea.</p>\n<p><img src=\"../../../assets/blog/Release-Step6.png\" alt=\"Task Configuration\"></p>\n<p>En primer lugar debemos establecer el origen de los documentos, en el apartado <em>Documentation Source</em>, examinamos y establecemos el resultado del artefacto</p>\n<p><img src=\"../../../assets/blog/Release-Step7.png\" alt=\"Task Configuration Source\"></p>\n<p>Una vez seleccionado el directorio, agregamos el wildcard <code>/**</code> para que publique el contenido de la carpeta del artefacto y no la carpeta en sí, así evitaremos que la publicación agregue a nuestro sitio un subdirectorio con el nombre del drop.</p>\n<p>A continuación completamos el resto de campos requeridos con las siguientes variables:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Name</th>\n<th align=\"left\">Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">Documentation Source</td>\n<td align=\"left\">$(System.DefaultWorkingDirectory)/DemoGatsbyJS/drop/**</td>\n</tr>\n<tr>\n<td align=\"left\">GitHub Username</td>\n<td align=\"left\">$(UserName)</td>\n</tr>\n<tr>\n<td align=\"left\">GitHub Email Address</td>\n<td align=\"left\">$(UserEmail)</td>\n</tr>\n<tr>\n<td align=\"left\">GitHub Personal Access Token</td>\n<td align=\"left\">$(PAT)</td>\n</tr>\n<tr>\n<td align=\"left\">Repository Name</td>\n<td align=\"left\">$(Repository)</td>\n</tr>\n<tr>\n<td align=\"left\">Branch Name</td>\n<td align=\"left\">gh-pages</td>\n</tr>\n<tr>\n<td align=\"left\">Commit Message</td>\n<td align=\"left\">Azure DevOps: Automated Release $(Release.ReleaseId)</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"../../../assets/blog/Release-Step8.png\" alt=\"Task Configuration\"></p>\n<p>En la pestaña de Variables, agregamos las variables que estamos utilizando en la tarea, y el PAT lo marcamos como variable de tipo <em>Secret</em>.</p>\n<p><img src=\"../../../assets/blog/Release-Step9.png\" alt=\"Task Variables\"></p>\n<p>Establecemos un nombre al <code>Release Pipeline</code>, pinchando sobre el nombre actual, guardamos y pulsamos en <em>Create release</em>.</p>\n<p><img src=\"../../../assets/blog/Release-CreateRelease.png\" alt=\"Create Release\"></p>\n<p>Accedemos a la Release creada, y una vez completado el proceso, si todo ha ido Ok, se mostrará un <em>Succeeded</em> en el Stage.</p>\n<p><img src=\"../../../assets/blog/Release-Completed.png\" alt=\"Release Completed\"></p>\n<p>Si vamos al resultado del Stage, podemos ver que, como con las Pipeline, se puede visualizar los logs de lo que ha sucedido durante el proceso.</p>\n<p><img src=\"../../../assets/blog/Release-CompletedLog.png\" alt=\"Release Log\"></p>\n<p>Finalmente en el navegador, si entramos al sitio estático de GitHub Pages, visualizaremos algo como esto.</p>\n<p><img src=\"../../../assets/blog/Gatsby-StarterWeb-GitHubPages.png\" alt=\"GitHub Pages\"></p>","frontmatter":{"title":"GatsbyJS en GitHub Pages con Azure DevOps","date":"2020, May 17","description":"Despliega tu sitio web estático hecho con GatsbyJS en GitHub Pages con Azure DevOps.","tags":["Azure DevOps","GitHub Pages","GatsbyJS"],"img":{"childImageSharp":{"fluid":{"aspectRatio":1.941544885177453,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMBBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHs5YklS//EABgQAQEBAQEAAAAAAAAAAAAAAAECAxAR/9oACAEBAAEFAqaHRrzNWO//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAaEAACAgMAAAAAAAAAAAAAAAAAAREiIDFR/9oACAEBAAY/AlCK92Ww/8QAGRABAQEBAQEAAAAAAAAAAAAAAREAIVEx/9oACAEBAAE/ITKgpgA4sMWHutvqvZKezTIJHHDf/9oADAMBAAIAAwAAABBMD//EABYRAAMAAAAAAAAAAAAAAAAAAAEQQf/aAAgBAwEBPxAVf//EABYRAQEBAAAAAAAAAAAAAAAAAAEQMf/aAAgBAgEBPxBwn//EABwQAQEAAgIDAAAAAAAAAAAAAAERACExUWFxof/aAAgBAQABPxCJ4SxdXfzN1k+Y3T3DxcNGkgrEodFNzIthcQAI8iYAAADgM//Z","sizes":"(max-width: 1940px) 100vw, 1940px","src":"/static/3e0e25a8b98af55bd3d2e435e7fdfbaa/6b48d/DevOps%2BGitHub.jpg","srcSet":"/static/3e0e25a8b98af55bd3d2e435e7fdfbaa/2f037/DevOps%2BGitHub.jpg 930w,\n/static/3e0e25a8b98af55bd3d2e435e7fdfbaa/23f4e/DevOps%2BGitHub.jpg 1860w,\n/static/3e0e25a8b98af55bd3d2e435e7fdfbaa/6b48d/DevOps%2BGitHub.jpg 1940w"}}}}}},"pageContext":{"slug":"/2020/05/17/","previous":{"fields":{"slug":"/2020/05/16/"},"frontmatter":{"title":"GitHub Pages + GatsbyJS","tags":["Basics","GitHub Pages","GatsbyJS"],"img":{"childImageSharp":{"fluid":{"aspectRatio":1.941544885177453,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAgAD/8QAFgEBAQEAAAAAAAAAAAAAAAAAAQME/9oADAMBAAIQAxAAAAHEC01UZf/EABgQAAMBAQAAAAAAAAAAAAAAAAECIRAT/9oACAEBAAEFAgF5rS0O/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAaEAACAgMAAAAAAAAAAAAAAAAAAREhICJR/9oACAEBAAY/Am524WVh/8QAGBABAAMBAAAAAAAAAAAAAAAAAQARUSD/2gAIAQEAAT8hWx4gGKAUVnH/2gAMAwEAAgADAAAAED8P/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQIBAT8Qh//EABoQAQEAAgMAAAAAAAAAAAAAAAERAEEgITH/2gAIAQEAAT8QCeLojk5UCwZUPLrI2l6eH//Z","sizes":"(max-width: 1940px) 100vw, 1940px","src":"/static/faf76886edea207a7f413fc74793eae9/6b48d/GatsbyJS.jpg","srcSet":"/static/faf76886edea207a7f413fc74793eae9/2f037/GatsbyJS.jpg 930w,\n/static/faf76886edea207a7f413fc74793eae9/23f4e/GatsbyJS.jpg 1860w,\n/static/faf76886edea207a7f413fc74793eae9/6b48d/GatsbyJS.jpg 1940w"}}}}},"next":{"fields":{"slug":"/2020/05/23/"},"frontmatter":{"title":"Integration Assistant Azure AD","tags":["Azure","Azure AD","Microsoft Identity Platform"],"img":{"childImageSharp":{"fluid":{"aspectRatio":1.941544885177453,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGQAAAQUAAAAAAAAAAAAAAAAAAAECAwQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAgH/2gAMAwEAAhADEAAAAcyyxKAjEf/EABkQAAMAAwAAAAAAAAAAAAAAAAABAxIyM//aAAgBAQABBQKKFZmQuC1P/8QAFhEBAQEAAAAAAAAAAAAAAAAAARAh/9oACAEDAQE/AUyf/8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQIBAT8BGf/EABsQAAIBBQAAAAAAAAAAAAAAAAECEAARIVKB/9oACAEBAAY/Ai2oq2Ifk//EABwQAAICAgMAAAAAAAAAAAAAAAABETEhUWGhsf/aAAgBAQABPyFl+JGt6GU/CIOR3RSM/9oADAMBAAIAAwAAABDPL//EABYRAQEBAAAAAAAAAAAAAAAAAAABIf/aAAgBAwEBPxCekf/EABYRAQEBAAAAAAAAAAAAAAAAABEBEP/aAAgBAgEBPxC6Z//EABwQAQEBAAIDAQAAAAAAAAAAAAERADFRIWGBkf/aAAgBAQABPxAoTJAylg/cQKEryLr3m2gXtXAJEpePuIog4F4N/9k=","sizes":"(max-width: 1940px) 100vw, 1940px","src":"/static/179817ecd26e6c802e35ccd5032bed6f/6b48d/Preview.jpg","srcSet":"/static/179817ecd26e6c802e35ccd5032bed6f/2f037/Preview.jpg 930w,\n/static/179817ecd26e6c802e35ccd5032bed6f/23f4e/Preview.jpg 1860w,\n/static/179817ecd26e6c802e35ccd5032bed6f/6b48d/Preview.jpg 1940w"}}}}}}}}