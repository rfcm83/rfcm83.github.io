<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[SetValue.NET]]></title><description><![CDATA[Mi nombre es Raúl Fernández de Córdoba, trabajo en Kabel como Cloud Solution Architect. En mi día a día, trato de definir las bases de las distintas soluciones técnicas que se van a implementar, asesorar y definir las mejores estrategias para resolver una necesidad.]]></description><link>http://setvalue.net</link><generator>GatsbyJS</generator><lastBuildDate>Sat, 30 May 2020 12:03:27 GMT</lastBuildDate><item><title><![CDATA[Integration Assistant Azure AD]]></title><description><![CDATA[Azure Active Directory tiene una novedad en el registro de aplicaciones para facilitar la configuración de un registro de aplicación. Hace poco se ha incluido una novedad en el registro de aplicaciones de Azure Active Directory. Azure siempre está incorporando alguna…]]></description><link>http://setvalue.net/2020/05/23/</link><guid isPermaLink="false">http://setvalue.net/2020/05/23/</guid><category><![CDATA[Azure]]></category><category><![CDATA[Azure AD]]></category><category><![CDATA[Microsoft Identity Platform]]></category><pubDate>Sat, 23 May 2020 08:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Hace poco se ha incluido una novedad en el registro de aplicaciones de &lt;strong&gt;Azure Active Directory&lt;/strong&gt;. Azure siempre está incorporando alguna novedad, y ésta no podría ser más útil.&lt;/p&gt;
&lt;p&gt;Tal y cómo se autodefine, su objetivo es ayudar a construir integraciones de alta calidad y seguras. Te muestra cuáles son las &lt;em&gt;best practices&lt;/em&gt; y recomendaciones para ayudar a evitar descuidos habituales cuando nos integramos con la &lt;strong&gt;Microsoft Identity Platform&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;App Registration&lt;/h2&gt;
&lt;p&gt;En la configuración del Azure Active Directory, en el apartado de &lt;a href=&quot;https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredApps&quot; target=&quot;_blank&quot;&gt;App Registrations&lt;/a&gt;, podemos seleccionar una aplicación que conozcamos cómo está configurada, y accedemos a su información del registro.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/AppRegistration-Overview.png&quot; alt=&quot;App Registration&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Integration Assistant&lt;/h2&gt;
&lt;p&gt;En el menú lateral, encontramos un blade llamado &lt;strong&gt;Integration Assistant (preview)&lt;/strong&gt;. Al acceder a él por primera vez, aparece un check list con el tipo de aplicación.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/AppRegistration-IAssistant.png&quot; alt=&quot;Integration Assistant&quot;&gt;&lt;/p&gt;
&lt;p&gt;Una vez definido el tipo de aplicación que es, se evalúa y muestra el resumen de acciones verificadas.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/IntegrationAssistant-Summary.png&quot; alt=&quot;Integration Assistant - Summary&quot;&gt;&lt;/p&gt;
&lt;p&gt;El resumen nos indica que no hay configurada una URL a la que redirigirse cuando se completa el login, lógico porque en concreto este registro está en blanco, no se ha configurado nada. Por otro lado, nos indica que si vamos a utilizar el flujo de autenticación implícito, debemos habilitar los ID Tokens. Y si queremos configurar un sign-out, debemos configurar también una URL de Logout.&lt;/p&gt;
&lt;h3&gt;Develop&lt;/h3&gt;
&lt;p&gt;En la pestaña de Desarrollo, está información básica,  y recomendaciones de implementación y de Experiencia de Usuario.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/IntegrationAssistant-Develop.png&quot; alt=&quot;Integration Assistant - Develop&quot;&gt;&lt;/p&gt;
&lt;p&gt;Estas recomendaciones nos dan acceso a artículos de la MSDN.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/IntegrationAssistant-Develop-Recommendation.png&quot; alt=&quot;Integration Assistant - Develop Recommendations&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Test&lt;/h3&gt;
&lt;p&gt;En la pestaña de Test, se incluyen otras recomendaciones relacionadas con el Testing y con la Experiencia de Usuario. Algunas de estas últimas también recomendadas en el apartado de &lt;strong&gt;Develop&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Sugerencias como que verifiques las políticas de Acceso Condicional por si pueden impedir a los usuarios utilizar la aplicación, resultan obvias, pero que no siempre reparamos en validarlo.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/IntegrationAssistant-Test.png&quot; alt=&quot;Integration Assistant - Test&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Release&lt;/h3&gt;
&lt;p&gt;El apartado de Release, nos muestra cuatro apartados:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ownership&lt;/strong&gt;. Nos recomienda agregar la información de contacto y que validemos si está realmente actualizada.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Branding&lt;/strong&gt;. Incluir la información de marca con el logo y el nombre que mejor represente a tu compañía o producto, y por supuesto asegurarte de que no afecta a ninguna marca registrada.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Security&lt;/strong&gt;. Minimizar y monitorizar manualmente la lista de propietarios de la aplicación o hacer rotados de credenciales.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;End user experience&lt;/strong&gt;. Incluir los certificados correspondientes si se está desarrollando una aplicación para Microsoft 365.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/IntegrationAssistant-Release.png&quot; alt=&quot;Integration Assistant - Release&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Monitor&lt;/h3&gt;
&lt;p&gt;El último apartado, encontramos recomendaciones de monitorización. Algunas ya incluidas en otros apartados, y otras orientadas al ciclo de vida de una aplicación.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/IntegrationAssistant-Monitor.png&quot; alt=&quot;Integration Assistant - Monitor&quot;&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[GatsbyJS en GitHub Pages con Azure DevOps]]></title><description><![CDATA[Despliega tu sitio web estático hecho con GatsbyJS en GitHub Pages con Azure DevOps.  Siguiendo con el anterior post en el que construíamos un sitio estático con GatsbyJS, nos enfrentamos a desplegar el resultado…]]></description><link>http://setvalue.net/2020/05/17/</link><guid isPermaLink="false">http://setvalue.net/2020/05/17/</guid><category><![CDATA[Azure DevOps]]></category><category><![CDATA[GitHub Pages]]></category><category><![CDATA[GatsbyJS]]></category><pubDate>Sun, 17 May 2020 06:35:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://github.com/rfcm83/DemoGatsbyJS/&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/rfcm83-DemoGatsbyJS-%3CCOLOR%3E.svg&quot; alt=&quot;Generic badge&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Siguiendo con el anterior &lt;a href=&quot;../16&quot;&gt;post&lt;/a&gt; en el que construíamos un sitio estático con GatsbyJS, nos enfrentamos a desplegar el resultado de esta web en un nuevo sitio de GitHub Pages.&lt;/p&gt;
&lt;p&gt;Para desplegar la aplicación, utilizaremos &lt;a href=&quot;https://dev.azure.com&quot; target=&quot;_blank&quot;&gt;Azure DevOps&lt;/a&gt;, creando dos pipelines, uno para la integración continua (CI &lt;em&gt;Continuous Integration&lt;/em&gt;) y otro para la entrega continua (CD &lt;em&gt;Continuous Delivery&lt;/em&gt;).&lt;/p&gt;
&lt;h2&gt;Configurando el repositorio&lt;/h2&gt;
&lt;p&gt;El primer paso que debemos realizar es preparar el repositorio para activar y configurar GitHub Pages.&lt;/p&gt;
&lt;p&gt;Creamos un nuevo branch llamado &lt;code&gt;gh-pages&lt;/code&gt; en el repositorio donde tenemos el sitio estático hecho con GatsbyJS.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/BranchCreateGH-Pages.png&quot; alt=&quot;New branch&quot;&gt;&lt;/p&gt;
&lt;p&gt;Configuramos GitHub Pages en este repositorio desde la pestaña de settings.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/GitHubPages-Settings.png&quot; alt=&quot;GitHub Pages Settings&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Nota&lt;/strong&gt;: Si tienes un Custom Domain ya agregado, GitHub Pages te sirve todos los sitios web desde el dominio que has configurado&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Por último, necesitaremos configurar un &lt;a href=&quot;https://github.com/settings/tokens&quot; target=&quot;_blank&quot;&gt;PAT (Personal access token)&lt;/a&gt; con permisos sobre repo.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/NewPAT.png&quot; alt=&quot;Create a new PAT&quot;&gt;&lt;/p&gt;
&lt;p&gt;Almacenamos el token en un lugar seguro para utilizarlo más adelante.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/PAT.png&quot; alt=&quot;New PAT&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Azure DevOps&lt;/h2&gt;
&lt;p&gt;En Azure DevOps debemos crear dos pipelines, el primero hará la build de la solución y generará un artefacto, el segundo utilizará este artefacto y lo publicará en la rama &lt;code&gt;gh-pages&lt;/code&gt; del repositorio en el que estamos trabajando.&lt;/p&gt;
&lt;h3&gt;Pipeline&lt;/h3&gt;
&lt;p&gt;Dentro del Team Project, en el menú seleccionamos el ítem &lt;strong&gt;Pipelines&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Pipeline-Step0.png&quot; alt=&quot;Pipeline&quot;&gt;&lt;/p&gt;
&lt;p&gt;Creamos un nuevo pipeline y elegimos como origen GitHub.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Pipeline-Step1.png&quot; alt=&quot;Connect Pipeline&quot;&gt;&lt;/p&gt;
&lt;p&gt;Seleccionamos el repositorio que queremos publicar como sitio estático.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Pipeline-Step2.png&quot; alt=&quot;Select Pipeline&quot;&gt;&lt;/p&gt;
&lt;p&gt;Al escoger el repositorio, deberemos configurar en GitHub el acceso que va a tener Azure Pipelines sobre nuestro repositorio. Tenemos dos opciones, dejar que tenga acceso a todos los repositorios, o dejar que sólo tenga acceso a los repositorios que seleccionemos.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Pipeline-Step2-Setup.png&quot; alt=&quot;Setup Azure Pipelines&quot;&gt;&lt;/p&gt;
&lt;p&gt;Tras aprobar el acceso al repositorio, volvemos al pipeline, y lo configuramos para que utilice Node.js.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Pipeline-Step3.png&quot; alt=&quot;Configure Pipeline&quot;&gt;&lt;/p&gt;
&lt;p&gt;En el último paso nos encontramos con un fichero YAML, con el nombre preestablecido de azure-pipelines.yml y que se almacenará en el repositorio de GitHub.&lt;/p&gt;
&lt;p&gt;Este fichero, viene por defecto con un trigger que se desencadenará cuando se consoliden cambios en &lt;code&gt;master&lt;/code&gt;, además realiza la instalación de Node.js, ejecuta la instalación de los paquetes npm y la compilación de la solución.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# Node.js
# Build a general Node.js project with npm.
# Add steps that analyze code, save build artifacts, deploy, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/javascript

trigger:
- master

pool:
  vmImage: &apos;ubuntu-latest&apos;

steps:
- task: NodeTool@0
  inputs:
    versionSpec: &apos;10.x&apos;
  displayName: &apos;Install Node.js&apos;

- script: |
    npm install
    npm run build
  displayName: &apos;npm install and build&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Actualizamos el código YAML que viene por defecto, modificando los pasos de la operativa para que instale el &lt;code&gt;Gatsby-CLI&lt;/code&gt;, y con &lt;code&gt;yarn&lt;/code&gt; instale las dependencias y haga la build de la solución.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# Build a GatsbyJS solution with npm and yarn.

trigger:
- master

pool:
  vmImage: &apos;ubuntu-latest&apos;

steps:
- task: NodeTool@0
  inputs:
    versionSpec: &apos;10.x&apos;
  displayName: &apos;Install Node.js&apos;

- script: |
    npm install -g gatsby-cli
  displayName: &apos;Install Gatsby-CLI&apos;

- script: |
    yarn install
  displayName: &apos;Install dependencies&apos;

- script: |
    yarn build
  displayName: &apos;Build&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En el lateral derecho, tenemos la posibilidad de utilizar el asistente, el cual nos permitirá cargar nuevos pasos dentro del YAML para completar el pipeline.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Pipeline-Step4-Assistant.png&quot; alt=&quot;Pipeline Assistant&quot;&gt;&lt;/p&gt;
&lt;p&gt;Agregamos dos pasos nuevos, el primero realizará la copia de los ficheros generados en la build. El segundo paso la publicación del resultado como artefacto.&lt;/p&gt;
&lt;p&gt;Para la copia de los ficheros, agregamos la tarea de copia e indicamos que debe copiar los ficheros que se generan en la carpeta &lt;em&gt;public&lt;/em&gt; al &lt;em&gt;Build Artifact Staging Directory&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;- task: CopyFiles@2
  inputs:
    sourceFolder: &quot;public&quot;
    contents: &quot;**&quot;
    targetFolder: &quot;$(Build.ArtifactStagingDirectory)&quot;
    cleanTargetFolder: true
  displayName: &quot;Copy built site&quot;
  condition: and(succeeded(), ne(variables[&apos;Build.Reason&apos;], &apos;PullRequest&apos;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tras la copia de ficheros, publicamos el resultado en el &lt;em&gt;Staging Artifact Directory&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: &quot;$(Build.ArtifactStagingDirectory)&quot;
    ArtifactName: &quot;drop&quot;
    publishLocation: &quot;Container&quot;
  condition: and(succeeded(), ne(variables[&apos;Build.Reason&apos;], &apos;PullRequest&apos;))
  displayName: &quot;Publish Build Artifacts&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Al finalizar las modificaciones, salvamos, establecemos el mensaje de &lt;code&gt;commit&lt;/code&gt; y automáticamente se lanzará un pipeline que generará los ficheros estáticos necesarios para un sitio web de GitHub Pages. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Pipeline-SaveAndRun.png&quot; alt=&quot;Pipeline Saven and run&quot;&gt;&lt;/p&gt;
&lt;p&gt;Una vez lanzado el pipeline, vemos el estado de la ejecución, y tenemos la posibilidad de ver los cambios o cancelar el propio pipeline.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Pipeline-Run.png&quot; alt=&quot;Pipeline Run&quot;&gt;&lt;/p&gt;
&lt;p&gt;Si pulsamos en el Job, podemos acceder al estado de la ejecución del pipeline y ver cómo va avanzando.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Pipeline-Run-Log.png&quot; alt=&quot;Pipeline Log&quot;&gt;&lt;/p&gt;
&lt;p&gt;Tras ejecutarse el pipeline, si no ha habido ningún error tendremos un tick verde en el resultado del Job, e internamente, en los logs, todas las operaciones estarán Ok y habrá un artefacto generado.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Pipeline-Run-Completed.png&quot; alt=&quot;Pipeline Log&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Release&lt;/h3&gt;
&lt;p&gt;Accedemos al ítem &lt;strong&gt;Release&lt;/strong&gt;, dentro del menú Pipelines.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Release-Step0.png&quot; alt=&quot;Release Menu&quot;&gt;&lt;/p&gt;
&lt;p&gt;Creamos una nueva Release Pipeline.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Release-Step1.png&quot; alt=&quot;New Release Pipeline&quot;&gt;&lt;/p&gt;
&lt;p&gt;En pantalla se nos mostrará un workflow para configurar nuestro &lt;code&gt;Release Pipeline&lt;/code&gt;, por defecto Azure DevOps nos ofrece plantillas predefinidas con diversa funcionalidad para facilitar esta tarea. En nuestro caso, seleccionamos una plantilla vacía.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Release-Step2.png&quot; alt=&quot;Select Template&quot;&gt;&lt;/p&gt;
&lt;p&gt;Establecemos un nombre al Stage, y vamos al bloque &lt;code&gt;Artifacts&lt;/code&gt;, dónde configuraremos el artefacto resultante de la pipeline que hemos creado en el punto anterior.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Release-Step3.png&quot; alt=&quot;Select Artifact&quot;&gt;&lt;/p&gt;
&lt;p&gt;Después de agregarlo, configuramos el trigger que desencadenará la &lt;code&gt;Release Pipeline&lt;/code&gt;, pulsando en el símbolo del &lt;em&gt;rayo&lt;/em&gt; del artefacto e indicamos la entrega continua con cada build que se produzca.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Release-Step4.png&quot; alt=&quot;Continuous deployment trigger&quot;&gt;&lt;/p&gt;
&lt;p&gt;En el bloque de &lt;code&gt;Stages&lt;/code&gt;, accedemos al Stage que tenemos y pulsamos sobre el resumen de &lt;em&gt;1 job, 0 task&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Release-Step5.png&quot; alt=&quot;Tasks Stage&quot;&gt;&lt;/p&gt;
&lt;p&gt;En el job del agente agregamos una nueva tarea del tipo &lt;em&gt;Publish to GitHub Pages&lt;/em&gt; y configuramos la tarea.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Release-Step6.png&quot; alt=&quot;Task Configuration&quot;&gt;&lt;/p&gt;
&lt;p&gt;En primer lugar debemos establecer el origen de los documentos, en el apartado &lt;em&gt;Documentation Source&lt;/em&gt;, examinamos y establecemos el resultado del artefacto&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Release-Step7.png&quot; alt=&quot;Task Configuration Source&quot;&gt;&lt;/p&gt;
&lt;p&gt;Una vez seleccionado el directorio, agregamos el wildcard &lt;code&gt;/**&lt;/code&gt; para que publique el contenido de la carpeta del artefacto y no la carpeta en sí, así evitaremos que la publicación agregue a nuestro sitio un subdirectorio con el nombre del drop.&lt;/p&gt;
&lt;p&gt;A continuación completamos el resto de campos requeridos con las siguientes variables:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;Name&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Documentation Source&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;$(System.DefaultWorkingDirectory)/DemoGatsbyJS/drop/**&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;GitHub Username&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;$(UserName)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;GitHub Email Address&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;$(UserEmail)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;GitHub Personal Access Token&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;$(PAT)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Repository Name&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;$(Repository)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Branch Name&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;gh-pages&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Commit Message&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Azure DevOps: Automated Release $(Release.ReleaseId)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Release-Step8.png&quot; alt=&quot;Task Configuration&quot;&gt;&lt;/p&gt;
&lt;p&gt;En la pestaña de Variables, agregamos las variables que estamos utilizando en la tarea, y el PAT lo marcamos como variable de tipo &lt;em&gt;Secret&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Release-Step9.png&quot; alt=&quot;Task Variables&quot;&gt;&lt;/p&gt;
&lt;p&gt;Establecemos un nombre al &lt;code&gt;Release Pipeline&lt;/code&gt;, pinchando sobre el nombre actual, guardamos y pulsamos en &lt;em&gt;Create release&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Release-CreateRelease.png&quot; alt=&quot;Create Release&quot;&gt;&lt;/p&gt;
&lt;p&gt;Accedemos a la Release creada, y una vez completado el proceso, si todo ha ido Ok, se mostrará un &lt;em&gt;Succeeded&lt;/em&gt; en el Stage.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Release-Completed.png&quot; alt=&quot;Release Completed&quot;&gt;&lt;/p&gt;
&lt;p&gt;Si vamos al resultado del Stage, podemos ver que, como con las Pipeline, se puede visualizar los logs de lo que ha sucedido durante el proceso.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Release-CompletedLog.png&quot; alt=&quot;Release Log&quot;&gt;&lt;/p&gt;
&lt;p&gt;Finalmente en el navegador, si entramos al sitio estático de GitHub Pages, visualizaremos algo como esto.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Gatsby-StarterWeb-GitHubPages.png&quot; alt=&quot;GitHub Pages&quot;&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[GitHub Pages + GatsbyJS]]></title><description><![CDATA[GitHub Pages y GatsbyJS.  En el anterior post se hablaba de qué era GitHub Pages, y cómo construir un sitio estático para documentar los repositorios o…]]></description><link>http://setvalue.net/2020/05/16/</link><guid isPermaLink="false">http://setvalue.net/2020/05/16/</guid><category><![CDATA[Basics]]></category><category><![CDATA[GitHub Pages]]></category><category><![CDATA[GatsbyJS]]></category><pubDate>Sat, 16 May 2020 13:35:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://github.com/rfcm83/DemoGatsbyJS/&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/rfcm83-DemoGatsbyJS-%3CCOLOR%3E.svg&quot; alt=&quot;Generic badge&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;En el anterior &lt;a href=&quot;../10&quot;&gt;post&lt;/a&gt; se hablaba de qué era GitHub Pages, y cómo construir un sitio estático para documentar los repositorios o un sitio web para un uso no comercial. &lt;/p&gt;
&lt;p&gt;Un sitio estático, no deja de ser contenido html, css y js. Aunque podemos utilizar una de las plantillas que nos ofrece GitHub Pages y a partir de ahí únicamente debemos subir ficheros markdown y ya la propia plantilla se encarga de construir la web estática. Sin embargo, esta aproximación no nos da mucho juego de cara a personalizar nuestro sitio.&lt;/p&gt;
&lt;p&gt;Para poder crear nuestro propio sitio, personalizado, con el formato y los contenidos que prefiramos, existen múltiples framework que facilitan esta acción. &lt;/p&gt;
&lt;p&gt;En este post, hacemos referencia a &lt;a href=&quot;https://gatsby.js/&quot; target=&quot;_blank&quot;&gt;GatsbyJS&lt;/a&gt;, un framework gratuito y opensource basado en React que permite construir sitios estáticos fácilmente.&lt;/p&gt;
&lt;h2&gt;Requisitos&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Node.js&lt;/li&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;li&gt;Visual Studio Code&lt;/li&gt;
&lt;li&gt;Repositorio GitHub&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Let&apos;s go&lt;/h2&gt;
&lt;p&gt;Si no está instalado Node, se puede descargar la versión apropiada para nuestro Sistema Operativo desde &lt;a href=&quot;https://nodejs.org/&quot; target=&quot;_blank&quot;&gt;aquí&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Repetimos la misma operativa para Git, si no está instalado, están son los enlaces a las versiones de cada sistema operativo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.atlassian.com/git/tutorials/install-git#mac-os-x&quot; target=&quot;_blank&quot;&gt;macOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.atlassian.com/git/tutorials/install-git#windows&quot; target=&quot;_blank&quot;&gt;Windows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.atlassian.com/git/tutorials/install-git#linux&quot; target=&quot;_blank&quot;&gt;Linux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para poder editar los ficheros de una forma ágil y sencilla, utilizaremos &lt;a href=&quot;https://code.visualstudio.com/#alt-downloads&quot; target=&quot;_blank&quot;&gt;Visual Studio Code&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Gatsby-cli&lt;/h3&gt;
&lt;p&gt;Se trata de una herramienta publicada como paquete &lt;code&gt;npm&lt;/code&gt; que permite crear rápidamente nuevos desarrollos basados en Gatsby y ejecutar comandos para sitios Gatsby.&lt;/p&gt;
&lt;p&gt;Este cliente nos va a permitir crear un sitio web en minutos, para ello instalamos el paquete npm de forma global desde línea de comandos.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;npm install -g gatsby-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Gatsby-CLI.png&quot; alt=&quot;Gatsby-CLI!&quot;&gt;&lt;/p&gt;
&lt;p&gt;Una vez completada la instalación, podemos consultar la lista de comandos disponible en cualquier momento con el comando &lt;code&gt;gatsby --help&lt;/code&gt;. &lt;/p&gt;
&lt;h3&gt;Crear sitio desde plantilla&lt;/h3&gt;
&lt;p&gt;Con el Gatsby-CLI instalado, creamos un nuevo sitio a partir de una de las &lt;a href=&quot;https://www.gatsbyjs.org/starters/?v=2&quot; target=&quot;_blank&quot;&gt;plantillas&lt;/a&gt; gratuitas que ofrece Gatsby y la comunidad.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gatsby new DemoGatsbyJS https://github.com/gatsbyjs/gatsby-starter-default
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Gatsby-StarterTemplate.png&quot; alt=&quot;Gatsby Starter Template!&quot;&gt;&lt;/p&gt;
&lt;p&gt;Cuando ya está completada la instalación, accedemos al directorio nuevo, e iniciamos la aplicación para explorar el nuevo sitio web.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd DemoGatsbyJS
gatsby develop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En el navegador, accediendo a &lt;a href=&quot;http://localhost:8000/&quot; _target=&quot;_blank&quot;&gt;localhost:8000&lt;/a&gt; podemos explorar el nuevo sitio web.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Gatsby-StarterWeb.png&quot; alt=&quot;Gatsby Starte Web&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Editar en Visual Studio Code&lt;/h3&gt;
&lt;p&gt;Para poder editar el nuevo sitio web, accedemos a Visual Studio Code desde el directorio en el que hemos creado la aplicación Web.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;code .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Una vez abierto el IDE, actualizamos el fichero &lt;code&gt;src/components/header.js&lt;/code&gt; y lo editamos:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import { Link } from &quot;gatsby&quot;
import PropTypes from &quot;prop-types&quot;
import React from &quot;react&quot;

const Header = ({ siteTitle }) =&gt; (
  &amp;#x3C;header
    style={{
      background: `#154D28`,
      marginBottom: `1.45rem`,
    }}
  &gt;
    &amp;#x3C;div
      style={{
        margin: `0 auto`,
        maxWidth: 960,
        padding: `1.45rem 1.0875rem`,
      }}
    &gt;
      &amp;#x3C;h1 style={{ margin: 0 }}&gt;
        &amp;#x3C;Link
          to=&quot;/&quot;
          style={{
            color: `white`,
            textDecoration: `none`,
          }}
        &gt;
          {siteTitle}
        &amp;#x3C;/Link&gt;
      &amp;#x3C;/h1&gt;
    &amp;#x3C;/div&gt;
  &amp;#x3C;/header&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Si no has cerrado la sesión del navegador con la web de la plantilla en &lt;code&gt;localhost:8000&lt;/code&gt;, el sitio se habrá actualizado el color morado por un verde oscuro. Si lo cerraste, vuelve a acceder después de lanzar un &lt;code&gt;gatsby develop&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/Gatsby-StarterWeb-Green.png&quot; alt=&quot;Gastby Starter Web Modified&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Git&lt;/h3&gt;
&lt;p&gt;Por último, agregamos los ficheros a un repositorio y hacemos commit.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git init
git remote add origin https://github.com/rfcm83/DemoGatsbyJS.git
git pull
git add .
git commit -m &apos;First commit Gatsby Web Starter Kit&apos;
git push origin master -f
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title><![CDATA[GitHub Pages]]></title><description><![CDATA[Cómo utilizar GitHub Pages para alojar tus páginas estáticas. Hola, bienvenidos. Hace años que no escribo en un blog, pero lo cierto es que de un tiempo hacía aquí, he pensado en volver a escribir, y…]]></description><link>http://setvalue.net/2020/05/10/</link><guid isPermaLink="false">http://setvalue.net/2020/05/10/</guid><category><![CDATA[Basics]]></category><category><![CDATA[GitHub Pages]]></category><pubDate>Sun, 10 May 2020 16:45:00 GMT</pubDate><content:encoded>&lt;p&gt;Hola, bienvenidos. Hace años que no escribo en un blog, pero lo cierto es que de un tiempo hacía aquí, he pensado en volver a escribir, y después de estar trasteando con algunos CMS basados en todo tipo de tecnologías (principalmente en .NET Core), me he decidido a probar GitHub Pages, y la verdad es que me he llevado una grata sorpresa.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pages.github.com&quot; target=&quot;_blank&quot;&gt;GitHub Pages&lt;/a&gt;, es un servicio de alojamiento de sitios estáticos que permite crear desde cero un sitio web personal, o crear uno para la documentación de un proyecto en GitHub. Los ficheros HTML, CSS y JavaScript provienen de un repositorio de GitHub.&lt;/p&gt;
&lt;p&gt;Se puede alojar un sitio en el dominio *.github.io o en un dominio propio.&lt;/p&gt;
&lt;p&gt;Existen tres tipos de sitios, proyecto, usuario y organización. &lt;/p&gt;
&lt;h2&gt;Sitios de Usuario o de Organización&lt;/h2&gt;
&lt;p&gt;Los sitios de Usuario u Organización son sitios que están conectados a una cuenta específica de GitHub. Estos repositorios tienen una serie de peculiaridades, y es que no pueden ser un repositorio privado, tampoco puede tener otro nombre, ni los ficheros alojarse que se visualizan en el sitio estar en una rama distinta a master.&lt;/p&gt;
&lt;p&gt;Para crear un sitio personal o de organización se deben seguir los siguientes pasos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Crear un nuevo repositorio en GitHub con el siguiente formato &lt;code&gt;username.github.io&lt;/code&gt;, donde &lt;code&gt;username&lt;/code&gt; es el nombre de usuario u organización en GitHub.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/CreateNewRepository.png&quot; alt=&quot;New Repo&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Clonar el repositorio&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;git clone https://github.com/username/username.github.io.git
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Agregar un fichero index.html con un &quot;Hola Mundo&quot;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;#x3C;!DOCTYPE html&gt;
&amp;#x3C;html&gt;
    &amp;#x3C;head&gt;
    &amp;#x3C;title&gt;Hola GitHub Pages!&amp;#x3C;/title&gt;
    &amp;#x3C;/head&gt;
    &amp;#x3C;body&gt;
        Hola Mundo!
    &amp;#x3C;/body&gt;
&amp;#x3C;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Push de los cambios&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;git add --all
git commit -m &quot;Primer commit, hola mundo&quot; 
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Acceder al nuevo sitio&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/HelloWorld.png&quot; alt=&quot;Hello World!&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Sitio de Proyecto&lt;/h2&gt;
&lt;p&gt;A diferencia de los otros tipos de sitios, estos permiten crear un website a partir de una rama o una carpeta de un repositorio existente, por supuesto, el repositorio no puede cumplir con la convención de nombre (&lt;code&gt;username.github.io&lt;/code&gt;) establecida para los sitios de organización o personales.&lt;/p&gt;
&lt;p&gt;Sobre un repositorio de proyecto, se puede elegir uno de estos tres orígenes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Utilizar un branch llamado gh-pages&lt;/li&gt;
&lt;li&gt;Utilizar la rama master como origen para contruir el sitio&lt;/li&gt;
&lt;li&gt;Utilizar un directorio &quot;docs&quot; dentro de la rama master&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/ProjectGitHubPages.png&quot; alt=&quot;Project GitHub Pages&quot;&gt;&lt;/p&gt;
&lt;p&gt;Una vez seleccionada una configuración, se repite los pasos del 2 al 5 del anterior epígrafe y se obtiene un &quot;Hola Mundo&quot; en un sitio de Proyecto.&lt;/p&gt;
&lt;h2&gt;¿Listo para empezar?&lt;/h2&gt;
&lt;p&gt;Existen dos posibilidades para comenzar a crear un sitio web estático de GitHub Pages.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mediante plantillas&lt;/li&gt;
&lt;li&gt;Desde cero&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Basado en plantilla&lt;/h3&gt;
&lt;p&gt;GitHub Pages dispone de una gran variedad de plantillas para empezar a crear un nuevo sitio estático.&lt;/p&gt;
&lt;p&gt;Las plantillas se pueden seleccionar desde la sección GitHub Pages de la configuración del Repositorio.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/ChooseTheme.png&quot; alt=&quot;Choose a Theme&quot;&gt;&lt;/p&gt;
&lt;p&gt;Una vez seleccionada la plantilla, se procede a crear ficheros en formato markdown, creando un primer fichero &lt;code&gt;readme.md&lt;/code&gt;, una vez realizado el push, el sitio de GitHub Pages cargará el contenido del fichero aplicando la plantilla seleccionada.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../assets/blog/GitHubPagesTemplate.png&quot; alt=&quot;Hello World with GitHub Pages Template&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Desde cero&lt;/h3&gt;
&lt;p&gt;Otra opción es empezar a crear contenido estático, empezando con un fichero &lt;code&gt;index.html&lt;/code&gt;. Una vez realizado el primer push, el contenido nuevo estará disponible en GitHub Pages.&lt;/p&gt;
&lt;p&gt;Esta aproximación, aunque es más compleja, permite un mayor grado de personalización. Existen múltiples generadores de contenido estático que permiten crear las páginas y assets de una forma sencilla, lo cual facilita en gran medida la construcción de nuevos contenidos.&lt;/p&gt;
&lt;h2&gt;Límites y usos prohibidos&lt;/h2&gt;
&lt;p&gt;Los sitios de GitHub Pages tienen los siguientes límites:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Los repositorios de código de GitHub Pages tienen un límite recomendado de 1GB&lt;/li&gt;
&lt;li&gt;Los sitios no pueden superar 1GB&lt;/li&gt;
&lt;li&gt;Tienen un límite de ancho de banda de 100GB al mes&lt;/li&gt;
&lt;li&gt;Un máximo de 10 builds por hora&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;No se puede utilizar GitHub Pages como un hosting gratuito para negocio, e-commerce o cualquier otro uso comercial. Tampoco se puede utilizar para publicar violencia, sexo, spam o cualquier actividad ilegal.&lt;/p&gt;
&lt;h2&gt;Conclusiones&lt;/h2&gt;
&lt;p&gt;Antes de empezar un nuevo sitio de GitHub Pages es necesario comprender cuál es el escenario que aplica, si es un proyecto, o si es un sitio personal o de empresa, si se desea partir de cero o desde una plantilla. Y por supuesto, saber los límites y los usos que no están permitidos, pues no deja de ser un servicio gratuito que permite disponer en minutos de un sitio web publicado en GitHub Pages.&lt;/p&gt;</content:encoded></item></channel></rss>